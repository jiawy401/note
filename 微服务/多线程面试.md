### 1、多线程有什么用？

1. 发挥多核CPU的优势

   现在的电脑至少也是双核的，4/8/16核的也有不少，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。**单核CPU上所谓的“多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程“同时”运行罢了**。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

2. 防止阻塞

   从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程那么只要这个线程阻塞了，比方说远程读取某个数据，对端迟迟未返回又没有设置超市时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以放置这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其他任务的执行。

3. 便于建模

   这是另外一个没有那么明显的优点。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B ， 任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务那就简单很多了。

### 2、创建线程的方式

比较常见的问题，一般两种：

- 继承Thread 
- 实现Runnable接口
- Callable/future

至于那个好，不用说肯定是Runnable，因为实现接口的方式比继承的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。

### 3、start()方法和run()方法的区别

只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。

### 4、Runnable接口和Callable接口的区别

- Runnable接口中run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

这其实是一个很有用的特性，因为**多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知**，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。 而Callable+Future/FutureTask却可以获取多线程运行的结果， 可以在等待时间太长没获取到需要的数据的情况下取消线程的任务。

### 5、CyclicBarrier和CountDownLatch的区别

都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：

- CyclicBarrier在某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已， 该线程继续运行。
- CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务
- CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。

### 6、volatile关键字的作用

1. 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据
2. 代码底层执行不像我们高级语言java程序那么简单，它的执行是 **java代码->字节码->根据字节码执行对应的C/C++代码被编译成汇编语言->和硬件电路交互**，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题，使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。

从实践的角度，volatile的一个重要作用就是和CAS结合，保证了原子性，详细可以参考java.util.concurrent.atomic包下的类。

### 7、什么是线程安全

**如果你的代码在多线程下执行和在单线程下执行永远都获得一样的结果，那么你的diam就是线程安全的。**

1. 不可变

   像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用

2. 绝对线程安全

   不管运行时环境如何，调用都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比如：CopyOnWriteArrayList/CopyOnWriteArraySet

3. 相对线程安全

   相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector，有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException ,也就是**fail-fas机制**

4. 线程非安全

   ArrayList、LinkedList、HashMap等。

### 8、Java中如何获取到线程dump文件

死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取线程堆栈有两步：

1. 获取到线程的pid，可以通过使用jps命令， 在Linux环境还可以使用ps -ef | grep java 
2. 打印线程堆栈，可以通过使用jstack pid 命令，在Linux环境下还可以使用kill -3 pid 

另外提一点，Thread类提供了一个getStackTrace() 方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取到的是具体某个线程当前运行的堆栈，

### 9、一个线程如果出现了运行时异常会怎么样

如果这个异常没有被捕捉的话， 这个线程就停止执行了。另外重要的一点是：**如果这个线程持有某个某个对象的监视器，那么这个对象监视器就会被立即释放**。

### 10、如何在两个线程之间共享数据

通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、 await/signalAll进行唤起和等待，比如：阻塞队列BlockingQueue就是为线程之间共享数据而设计的

### 11、sleep方法和wait方法有什么区别

sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。

### 12、生产者消费者模型的作用是什么

1. **通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率**，这是生产者消费者模型最重要的作用
2. 解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。

### 13、ThreadLocal有什么作用

简单说ThreadLocal就是一种以**空间换时间**的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal，ThreadLocalMap， 把数据进行隔离，数据不共享，自然就没有线程安全方面的问题。

### 14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用

这是JDK强制的，wait()方法和notify()/notifyAll()方法的调用前都必须先获得对象的锁。

### 15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别

wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候区别在于： wait()方法立即释放对象监视器， notify()/notifyAll() 方法则会等待线程剩余代码执行完毕才会放弃对象监视器。

### 16、为什么要使用线程池

避免频繁地创建和销毁线程， 达到线程对象的重用。另外使用线程池还可以根据项目灵活地控制并发的数目。

### 17、怎么检测一个线程是否持有对象监视器

Thread类提供了一个holdsLock(Object object)方法， 当且仅当对象object的监视器被某条线程持有的时候才会返回true， 注意这是一个static方法，这意味着**“某条线程”指的是当前线程**。

### 18、Synchronized和ReentrantLock的区别

Synchronized是和if、else、 for、 while一样的关键字，ReentrantLock是类， 这是二者的本质的区别。既然ReentrantLock是类，那么它就提供了比Synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量， ReentrantLock比Synchronized的扩展性体现在几点上：

1. ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
2. ReentrantLock可以获取各种锁的信息
3. ReentrantLock可以灵活地实现多路通知。

另外， 二者的锁机制其实也不一样。ReentrantLock底层调用的是Unsafe的park方法加锁，Synchronized操作的应该是对象头中mark word，这不太确定

### 19、ConcurrentHashMap的并发度是什么

ConcurrentHashMap的并发度就是segment的大小，默认为16 ， 这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两天线程获取Hashtable中的数据吗？

### 20、ReadWriteLock是什么

首先明确下，不是说ReentrantLock不好， 只是ReentrantLock某些时候有局限性。如果使用ReentrantLock可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据， 读数据是不会改变数据的，没有必要加锁， 但是还是加锁了，降低了程序的性能。

因为这个才诞生了读写锁ReadWriteLock 。 ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离， **读锁是共享的， 写锁是独占的**，读与读之间不会互斥， 读与写、写与读、写与写才会互斥，提升了读写的性能。

### 21、FutureTask是什么

FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务得结果进行等待获取、判断是否已经完成、取消任务等操作。当然， 由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。

### 22、Linux环境下如何查找哪个线程使用CPU最长

1. 获取项目的pid, jps  或者 ps -ef | grep java 
2. top -H -p pid ,顺序不能改变

这样可以打印出当前的呃项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP， 也就是操作系统原生线程的线程号

使用“top -H -p pid " + "jps pid" 可以很容易地找到某条占用CPU高的线程的线程堆栈， 从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。

top -H -p pid 打出来的LWP是十进制的， “jps pid " 打出来的本地线程号是十六进制，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。

### 23、Java编程写一个会导致死锁的程序

第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。

真正理解什么是死锁，这个问题其实不难，几个步骤：

（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；

（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁

（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的

这样，线程1"睡觉"睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，[Java多线程7：死锁](http://www.cnblogs.com/xrq730/p/4853713.html)这篇文章里面有，就是上面步骤的代码实现。

### 24、怎么唤醒一个阻塞的线程

如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException 来唤醒它 ，；如果是IO阻塞那就无能为力了， IO是操作系统实现的。java并没有直接接触到操作系统。

### 25、不可变对象对多线程有什么帮助

不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。

### 26、什么是多线程上下文切换

多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

### 27、如果你提交任务时 ， 线程池队列已满，这是会发生什么？

这里区分一下：

1. 如果使用的是无界队列LinkedBlockingQueue ， 也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务。
2. 如果使用的是有界队列比如ArrayBlockingQUeue ， 任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了 ， 会根据maxinumPoolSize的值增加线程数量， 如果增加了线程数量还是处理不过来， ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandle处理满了的任务， 默认是AbortPolicy。

### 28、Java中用到的线程调度算法是什么

