### 1、多线程有什么用？

1. 发挥多核CPU的优势

   现在的电脑至少也是双核的，4/8/16核的也有不少，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。**单核CPU上所谓的“多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程“同时”运行罢了**。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

2. 防止阻塞

   从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程那么只要这个线程阻塞了，比方说远程读取某个数据，对端迟迟未返回又没有设置超市时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以放置这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其他任务的执行。

3. 便于建模

   这是另外一个没有那么明显的优点。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B ， 任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务那就简单很多了。

### 2、创建线程的方式

比较常见的问题，一般两种：

- 继承Thread 
- 实现Runnable接口
- Callable/future

至于那个好，不用说肯定是Runnable，因为实现接口的方式比继承的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。

### 3、start()方法和run()方法的区别

只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。

### 4、Runnable接口和Callable接口的区别

- Runnable接口中run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

这其实是一个很有用的特性，因为**多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知**，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。 而Callable+Future/FutureTask却可以获取多线程运行的结果， 可以在等待时间太长没获取到需要的数据的情况下取消线程的任务。

### 5、CyclicBarrier和CountDownLatch的区别

都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：

- CyclicBarrier在某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已， 该线程继续运行。
- CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务
- CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。