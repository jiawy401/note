# 第一课

## 并发/高并发

并发：单位时间内并发的线程数

高并发：短期内超大的请求量

硬件是基础，

### 硬件

CPU、内存、磁盘、网络

### 软件

> 最大化的利用硬件资源

线程数量、JVM内存分配大小、网络通信机制（BIO/NIO/AIO) 、磁盘IO

### 线程数量如何提升服务端的并发数量

------



### 并发和并行

------

单核心CPU也是可以支持多线程的->通过CPU的时间片切换

### 多线程的特点

------

- 异步：不需要阻塞当前的处理

![image-20210104150908375](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210104150908375.png)

- 并行： 多任务并行

![image-20210104151011523](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210104151011523.png)

线程是CPU最小的调度资源。



## java中的线程

- runnable 接口
- thread类
- Callable接口/Future

## 线程使用场景

- 网络请求分发的场景中
- 文件导入
- 短信发送场景
- .........

----------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------

## 线程的基础

### 线程的生命周期

---

线程的启动->结束。



> 阻塞

- WAITING
- TIME_WAITING
- BLOCKED
- IO阻塞

---

java的线程有多少状态：6种

![image-20210105133802412](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210105133802412.png)

### 操作系统中的线程状态：5种



### 线程的启动

new Thread().start();启动线程

new Thread().run();调用实例方法

start（）方法调用本地native的start0()方法，是在JVM层写的。

java里不提供线程，线程是操作系统提供的。

![image-20210105134705066](C:\learn\微服务\processon\image-20210105134705066.png)

### 线程的终止

> 线程生命情况下会终止

run方法执行结束，线程终止

stop()方法，但不建议使用，强制终止这个线程。

发送终止的通知。

isInterrupted()，默认是false

thread.interrupt(); 将标识改为true

- 设置一个共享变量的值为true
- 唤醒处于阻塞状态下的线程
- 本质上通过共享变量实现线程通信

但凡让线程阻塞的机制，它都会有一个InterruptedException抛出，来响应中断

![image-20210105141759428](C:\learn\微服务\processon\image-20210105141759428.png)

![image-20210105142517345](C:\learn\微服务\processon\image-20210105142517345.png)



# 第二课并发编程带来的挑战

- 线程的上下文切换
- 死锁
- - 死锁产生的条件
  - 如何避免死锁
- 线程安全问题
- - 原子性
  - 有序性
  - 可见性
- java中的同步锁Synchronized
- - Synchronized的基本应用
  - 思考锁背后的实现哲学
  - Synchronized的实现原理
  - 理解什么是锁升级

```java
public class App {

    public static  int count= 0;

    public static void incr(){
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count++;
    }

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0 ;i < 1000 ; i ++){
            new Thread(()-> App.incr()).start();
        }

        Thread.sleep(3000); //保证所有线程执行结束
        System.out.println("结果:" + count);
    }
}
```

结果是小于等于1000的随机数。

可见性、原子性

> 数据库里ACID

原子性体现在count++;

字节码：字节指令getstatic 访问一个静态常量  ， 字节指令putstatic 设置一个静态常量

count++ 分解的指令

```
 14:getstatic    #5                       //Field count:I
 15:iconst_1
 16:iadd
 17:putstatic    #5
```

![image-20210105152126519](C:\learn\微服务\processon\image-20210105152126519.png)

## 锁（Synchronized)



























