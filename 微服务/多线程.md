# 第一课

## 并发/高并发

并发：单位时间内并发的线程数

高并发：短期内超大的请求量

硬件是基础，

### 硬件

CPU、内存、磁盘、网络

### 软件

> 最大化的利用硬件资源

线程数量、JVM内存分配大小、网络通信机制（BIO/NIO/AIO) 、磁盘IO

### 线程数量如何提升服务端的并发数量

------



### 并发和并行

------

单核心CPU也是可以支持多线程的->通过CPU的时间片切换

### 多线程的特点

------

- 异步：不需要阻塞当前的处理

![image-20210104150908375](processon\image-20210104150908375.png)

- 并行： 多任务并行

![image-20210104151011523](processon\image-20210104151011523.png)

线程是CPU最小的调度资源。



## java中的线程

- runnable 接口
- thread类
- Callable接口/Future

## 线程使用场景

- 网络请求分发的场景中
- 文件导入
- 短信发送场景
- .........

----------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------

## 线程的基础

### 线程的生命周期

---

线程的启动->结束。



> 阻塞

- WAITING
- TIME_WAITING
- BLOCKED
- IO阻塞

---

java的线程有多少状态：6种

![image-20210105133802412](processon\image-20210105133802412.png)

### 操作系统中的线程状态：5种



### 线程的启动

new Thread().start();启动线程

new Thread().run();调用实例方法

start（）方法调用本地native的start0()方法，是在JVM层写的。

java里不提供线程，线程是操作系统提供的。

![image-20210105134705066](processon\image-20210105134705066.png)

### 线程的终止

> 线程生命情况下会终止

run方法执行结束，线程终止

stop()方法，但不建议使用，强制终止这个线程。

发送终止的通知。

isInterrupted()，默认是false

thread.interrupt(); 将标识改为true

- 设置一个共享变量的值为true
- 唤醒处于阻塞状态下的线程
- 本质上通过共享变量实现线程通信

但凡让线程阻塞的机制，它都会有一个InterruptedException抛出，来响应中断

![image-20210105141759428](processon\image-20210105141759428.png)

![image-20210105142517345](processon\image-20210105142517345.png)



# 第二课并发编程带来的挑战

- 线程的上下文切换
- 死锁
- - 死锁产生的条件
  - 如何避免死锁
- 线程安全问题
- - 原子性
  - 有序性
  - 可见性
- java中的同步锁Synchronized
- - Synchronized的基本应用
  - 思考锁背后的实现哲学
  - Synchronized的实现原理
  - 理解什么是锁升级

```java
public class App {

    public static  int count= 0;

    public static void incr(){
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count++;
    }

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0 ;i < 1000 ; i ++){
            new Thread(()-> App.incr()).start();
        }

        Thread.sleep(3000); //保证所有线程执行结束
        System.out.println("结果:" + count);
    }
}
```

结果是小于等于1000的随机数。

可见性、原子性

> 数据库里ACID：一个事物里面操作要么同时成功 或同时失败。

原子性体现在count++;

线程原子性：一系列或者一个指令它的操作是不可中断的

字节码：字节指令getstatic 访问一个静态常量  ， 字节指令putstatic 设置一个静态常量

count++ 分解的指令

```
 14:getstatic    #5                       //Field count:I
 15:iconst_1
 16:iadd
 17:putstatic    #5
```

![image-20210105152126519](processon\image-20210105152126519.png)

## 锁（Synchronized)

### 锁的范围

---

- 实例锁：决定在当前实例的对象里面。

![image-20210118111404391](processon\image-20210118111404391.png)

互斥锁的本质是什么

->共享资源

红色、绿色来标记互斥

```java
public class SynchronizedDemo {
    Object object = new Object();
    void demo3(){
        synchronized (object){
            //线程安全性问题
        }
    }
    //锁的范围
    //实例锁：决定在当前实例的对象里面。
    public static void main(String[] args) {
        SynchronizedDemo synchronizedDemo = new SynchronizedDemo();
        //锁的互斥性,当t1获得了锁 ，在t1释放锁之前t2需要等待
        new Thread(() ->{
            synchronizedDemo.demo();
        } , "t1").start();
        new Thread(() ->{
            synchronizedDemo.demo();
        }, "t2").start();
    }
}
```

- 类锁: 静态方法、类对象、类锁

```java
public class SynchronizedDemo {
  
    synchronized static  void demo2(){

    }
    void demo01(){
        synchronized (SynchronizedDemo.class){

        }
    } 
    //锁的范围
    //实例锁：决定在当前实例的对象里面。
    //静态方法、类对象、类锁
    public static void main(String[] args) {
        SynchronizedDemo synchronizedDemo = new SynchronizedDemo();
        SynchronizedDemo synchronizedDemo2 = new SynchronizedDemo();

        //锁的互斥性,当t1获得了锁 ，在t1释放锁之前t2需要等待
        new Thread(() ->{
            synchronizedDemo.demo();
        } , "t1").start();
        new Thread(() ->{
        }, "t2").start();
    }

}
```

- 代码块

### 锁的存储（对象头）

对象头：我们的对象在内存中的布局

![image-20210106135710632](processon\image-20210106135710632.png)



![image-20210106140004059](processon\image-20210106140004059.png)

 

![image-20210106140039580](processon\image-20210106140039580.png)

### 打印类的布局

```xml
        <!--打印类的布局的-->
        <dependency>
            <groupId>org.openjdk.jol</groupId>
            <artifactId>jol-core</artifactId>
            <version>0.10</version>
        </dependency> 
```

```java
/**
 * 打印类的布局
 */
public class ClassLayoutDemo {
    public static void main(String[] args) {
        ClassLayoutDemo classLayoutDemo = new ClassLayoutDemo();
        System.out.println(ClassLayout.parseInstance(classLayoutDemo).toPrintable());
        /**
         * 打印结果：
         * com.jiawy.springbootthread.thread2_1.ClassLayoutDemo object internals:  
           (偏移量)(占用大小)(类型) 
         *  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
         *       0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
         *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
         *       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
         *      12     4        (loss due to the next object alignment)
         * Instance size: 16 bytes
         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
         */
    }
}
```



```
 *       0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
 *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
```

00 00 00 00 00 00 00 01

### 锁的升级

![image-20210118143820022](processon\image-20210118143820022.png)

**偏向锁**

开启偏向锁

```txt
VM options：-XX:+UsebiasedLocking -XX:BiasedLockingStartupDelay=0
```

---

Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。
**偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。**
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。(**偏向锁只能在单线程下起作用**)

锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。
机制：每个锁都关联一个请求计数器和一个占有他的线程，当请求计数器为0时，这个锁可以被认为是unhled的，当一个线程请求一个unheld的锁时，JVM记录锁的拥有者，并把锁的请求计数加1，如果同一个线程再次请求这个锁时，请求计数器就会增加，当该线程退出syncronized块时，计数器减1，当计数器为0时，锁被释放（这就保证了锁是可重入的，不会发生死锁的情况）。

**偏向锁，简单的讲，就是在锁对象的对象头中有个ThreaddId字段，这个字段如果是空的，第一次获取锁的时候，就将自身的ThreadId写入到锁的ThreadId字段内，将锁头内的是否偏向锁的状态位置1.这样下次获取锁的时候，直接检查ThreadId是否和自身线程Id一致，** 如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁，略过了轻量级锁和重量级锁的加锁阶段。提高了效率。
但是偏向锁也有一个问题，就是当锁有竞争关系的时候，需要解除偏向锁，使锁进入竞争的状态。

偏向锁的释放之后会进入到轻量级锁阶段，两个线程进入锁竞争状态，一个具体例子可以参考synchronized锁机制。
**synchronized锁流程如下：**
第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁”
第二步，如果MarkWord不是自己的ThreadId,锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。
第三步，两个线程都把对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作，把共享对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord,
第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋
第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败
第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己

**因此 流程是这样的 偏向锁->轻量级锁->重量级锁(由这三个关键词串联起来的过程才是最重要的)**

总结：
**偏向锁，其实是无锁竞争下可重入锁的简单实现**

-----



【乐观锁的概念】：

CAS（）比较预期数据和原始数据是否一致，如果一致则修改，不一致则不改

### 重量级锁

![image-20210118142248182](processon\image-20210118142248182.png)

示例：

```java
package com.jiawy.springbootthread.thread2_1;

import org.openjdk.jol.info.ClassLayout;

public class LockDemo {
//    public static void main(String[] args) {
//        LockDemo lockDemo = new LockDemo();
//        Thread t1 = new Thread(()->{
//           synchronized (lockDemo){
//               System.out.println("t1抢占到锁");
//               System.out.println(ClassLayout.parseInstance(lockDemo).toPrintable());
//           }
//        });
//        t1.start();
//
//        synchronized (lockDemo){
//            System.out.println("Main抢占锁");
//            System.out.println(ClassLayout.parseInstance(lockDemo).toPrintable());
//        }
//
//        /**
//         * Main抢占锁
//         * com.jiawy.springbootthread.thread2_1.LockDemo object internals:
//         *  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
//         *       0     4        (object header)                           2a d5 57 1f (00101010 11010101 01010111 00011111) (525849898)
//         *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
//         *       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
//         *      12     4        (loss due to the next object alignment)
//         * Instance size: 16 bytes
//         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
//         *
//         * t1抢占到锁
//         * com.jiawy.springbootthread.thread2_1.LockDemo object internals:
//         *  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
//         *       0     4        (object header)                           2a d5 57 1f (00101010 11010101 01010111 00011111) (525849898)
//         *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
//         *       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
//         *      12     4        (loss due to the next object alignment)
//         * Instance size: 16 bytes
//         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
//         */
//    }
    public static void main(String[] args) throws InterruptedException {
        LockDemo lockDemo = new LockDemo();
        Thread t1 = new Thread(()->{
           synchronized (lockDemo){
               System.out.println("t1抢占到锁");
               System.out.println(ClassLayout.parseInstance(lockDemo).toPrintable());
           }
        });
        t1.start();
        Thread.sleep(10000);  //每一个锁之间是独立的，这样锁就是轻量级锁
        synchronized (lockDemo){
            System.out.println("Main抢占锁");
            System.out.println(ClassLayout.parseInstance(lockDemo).toPrintable());
        }

        /**
         * Main抢占锁
         * com.jiawy.springbootthread.thread2_1.LockDemo object internals:
         *  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
         *       0     4        (object header)                           2a d5 57 1f (00101010 11010101 01010111 00011111) (525849898)
         *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
         *       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
         *      12     4        (loss due to the next object alignment)
         * Instance size: 16 bytes
         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
         *
         * t1抢占到锁
         * com.jiawy.springbootthread.thread2_1.LockDemo object internals:
         *  OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
         *       0     4        (object header)                           2a d5 57 1f (00101010 11010101 01010111 00011111) (525849898)
         *       4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
         *       8     4        (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
         *      12     4        (loss due to the next object alignment)
         * Instance size: 16 bytes
         * Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
         */
    }
}

```

### 线程的通信（wait/notify)

----

d