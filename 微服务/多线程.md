# 第一课

## 并发/高并发

并发：单位时间内并发的线程数

高并发：短期内超大的请求量

硬件是基础，

### 硬件

CPU、内存、磁盘、网络

### 软件

> 最大化的利用硬件资源

线程数量、JVM内存分配大小、网络通信机制（BIO/NIO/AIO) 、磁盘IO

### 线程数量如何提升服务端的并发数量

------



### 并发和并行

------

单核心CPU也是可以支持多线程的->通过CPU的时间片切换

### 多线程的特点

------

- 异步：不需要阻塞当前的处理

![image-20210104150908375](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210104150908375.png)

- 并行： 多任务并行

![image-20210104151011523](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210104151011523.png)

线程是CPU最小的调度资源。



## java中的线程

- runnable 接口
- thread类
- Callable接口/Future

## 这个工具怎么去使用

- 网络请求分发的场景中
- 文件导入
- 短信发送场景

----------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------

## 线程的基础

### 线程的生命周期

---

线程的启动->结束。



> 阻塞

- WAITING
- TIME_WAITING
- BLOCKED
- IO阻塞

---

## java的线程有多少状态：6种

![image-20210105133802412](C:\Users\xsk\AppData\Roaming\Typora\typora-user-images\image-20210105133802412.png)

## 操作系统中的线程状态：5种



## 线程的启动

new Thread().start();启动线程

new Thread().run();调用实例方法

start（）方法调用本地native的start0()方法，是在JVM层写的。

java里不提供线程，线程是操作系统提供的。

![image-20210105134705066](C:\learn\微服务\processon\image-20210105134705066.png)

## 线程的终止

> 线程生命情况下会终止

run方法执行结束，线程终止

stop()方法，但不建议使用，强制终止这个线程。

发送终止的通知。

isInterrupted()，默认是false

thread.interrupt(); 将标识改为true

- 设置一个共享变量的值为true
- 唤醒处于阻塞状态下的线程

但凡让线程阻塞的机制，它都会有一个InterruptedException抛出，来响应中断

![image-20210105141759428](C:\learn\微服务\processon\image-20210105141759428.png)

![image-20210105142517345](C:\learn\微服务\processon\image-20210105142517345.png)





































